
# Какво е клас?
В C++ класът е шаблон за създаване на обекти. Той дефинира данни (член-променливи) и поведение (член-функции, методи), които обектите ще имат.
# Разлика между struct и class
Основната разлика между структурите и класовете е, че по подразбиране: 
- В `struct` всички членове имат `public` модификатор за достъп.
- В `class` всички членове имат `private` модификатор за достъп.

*Пример*
```cpp
struct Point {
	int x;
	int y;
};

class Rectangle {
private:
	Point leftTop;
	Point rightBottom;
public:
	Rectangle(const Point& p1, const Point& p2);
	unsigned getPerimeter() const;
	unsigned getArea() const;
};
```
# Access Modifiers (Модификатори за достъп)

Access модификаторите в C++ са механизъм за контролиране на достъпа до членовете на класовете и структурите. 
- **`public`** – Членове с публичен достъп са достъпни отвън, което означава, че всеки друг код, функция или клас може да ги използва. Обикновено се използват за дефиниране на публичния интерфейс на класа – методи и данни, които са предназначени за външна употреба. Това улеснява взаимодействието с обекта и дава възможност на потребителите на класа да извикват неговите функции или да четат определени данни. 

- **`private`** – Членове с частен достъп са достъпни само вътре в самия клас, в който са декларирани. Това ограничава достъпа до вътрешната реализация на класа и предпазва данните от директна манипулация извън неговия контрол. Използването на `private` модификатора помага за поддържането на целостта на данните, като задължава външния код да взаимодейства с класа чрез предварително дефинирани публични методи (например getter-и и setter-и). 

- **`protected`** – Членове с защитен достъп са достъпни в класа, както и в неговите наследници (деца, подкласове), но не и извън тях. Това позволява на наследените класове да използват и модифицират тези членове, без те да бъдат напълно публични. `Protected` модификаторът се използва, когато искате да осигурите определена степен на достъпност за разширяване на функционалността чрез наследяване, като същевременно запазвате контрола върху вътрешните данни.

# Конструктори

Конструкторите са специални методи, които се извикват автоматично при създаването на обект от даден клас. Те имат следните основни характеристики:
- **Име:** Същото име като класа.
- **Липса на тип на връщане:** Няма да върнат стойност, дори и void.
- **Автоматично извикване:** Използват се за инициализация на данните и задаване на началното състояние на обекта.

## Видове конструктори
- **Default конструктор:** Конструктор без параметри. Ако не бъде дефиниран, компилаторът генерира такъв автоматично.
- **Parameterized конструктор:** Позволява инициализация на обекта със специфични стойности, предоставени като аргументи.
- **Copy конструктор:** Използва се за създаване на нов обект като копие на съществуващ такъв. За него ще говорим в следващо занятие

## Пример за конструктори

```cpp
#include <iostream>

class Point {
private:
    int x, y;
public:
    // Default конструктор
    Point() : x(0), y(0) {}

    // Parameterized конструктор
    Point(int x, int y) : x(x), y(y) {}

    // Copy конструктор
    Point(const Point& other) : x(other.x), y(other.y) {}

    void print() const {
        std::cout << "Point(" << x << ", " << y << ")" << std::endl;
    }
};

int main() {
    Point p1;            // Използва default конструктора
    Point p2(10, 20);    // Използва parameterized конструктора
    Point p3(p2);        // Използва copy конструктора

    p1.print();  // Извежда: Point(0, 0)
    p2.print();  // Извежда: Point(10, 20)
    p3.print();  // Извежда: Point(10, 20)
    
    return 0;
}

```

# Ключова дума this

Ключовата дума `this` представлява указател към текущия обект (инстанция) на класа. Той се използва вътре в методите на класа, за да:

- Различава член-променливите от параметрите с еднакви имена.
- Връща текущата инстанция, например при `method chaining`

```cpp
class Example {
private:
    int number;
public:
    Example(int number) {
        // Използваме this->, за да разграничим член-променливата от параметъра
        this->number = number;
    }
    Example& updateNumber(int number) {
        this->number = number;
        return *this;
    }
};

```

*Бележка: this->number е кратък запис за (\*this).number.

---

# Задача 1

Създайте клас с име **Rational**, който да представлява рационално число.

- Класът **Rational** трябва да има две **private** полета: **numerator** (числител) и **denominator** (знаменател), и двете от тип `int`.

- Класът трябва да съдържа конструктор, който приема два параметъра (за числителя и знаменателя). В конструктора трябва да бъде имплементирана валидация на входните данни, така че да се осигури, че знаменателят няма да бъде нула. Пример:
  `throw std::invalid_argument("Denominator cannot be zero!");`

- Класът трябва да има следните член-функции:
	
	- **`void print() const`** – Извежда рационалното число във формат `числител/знаменател`.
	- **`bool isInteger() const`** – Проверява дали числото е цяло (`true`, ако `numerator % denominator == 0`).
	- **`Rational add(const Rational& rhs) const`** – Събиране на две рационални числа.
	- **`Rational subtract(const Rational& rhs) const`** – Изваждане на две рационални числа.
	- **`Rational multiply(const Rational& rhs) const`** – Умножение на две рационални числа.
	- **`Rational divide(const Rational& rhs) const`** – Деление на две рационални числа. Ако `rhs.numerator == 0`, да се хвърли `std::runtime_error("Division by zero!")`.
	- **`int floor() const`** – Връща цяло число, като закръгля надолу
	- **`int ceil() const`** – Връща цяло число, като закръгля нагоре 

- След всяка аритметична операция, числителят и знаменателят трябва **автоматично да се опростят** до най-простата си форма.
	- Пример: `Rational(1024, 2048)` трябва да се преобразува в `Rational(1, 2)`.