# Week 01. Tests and text files

## Unit Tests in C++ with Catch
Unit testing е метод за софтуерно тестване, при което отделни компненти от програмата се тестват, за да се подсигурим, че работят коректно.

### Catch Framework Basics

```cpp
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
```
`#define CATCH_CONFIG_MAIN` макросът генерира `main` функция, за да може програмата да изпълни тестовете.

### Писане на Test Cases

Тестовият случай е единична, изолирана единица за тестване, предназначена за проверка на конкретен аспект от поведението на програмата. Тестовият случай обикновено включва:

- Описание - Какво се тества.
- Настройка на теста (Arrange) - Подготовка на необходимите обекти и входни данни.
- Изпълнение (Act) - Извършване на операцията, която се тества.
- Проверка (Assert) - Проверка дали резултатът съответства на очакваното поведение.

Тест в Catch се дефинира, използвайки `TEST_CASE`. Така се групират свързани тестове заедно и се предоставя описание.

```cpp
TEST_CASE("Person creation with valid data")
{
    // Arrange
    bool gender = false;
    int age = 12;
    const char* name = "Hi";

    // Act
    Person p = createPerson(gender, age, name);

    // Assert
    REQUIRE(p.gender == gender);
    REQUIRE(p.age == age);
    REQUIRE(strcmp(p.name, name) == 0);
}
```

#### Arrange-Act-Assert (AAA) Pattern
Шаблонът Arrange-Act-Assert (AAA) е обща структура, използвана при Unit Test-ването, за да се подобри яснотата и поддържането. Той разделя тестовия случай на три отделни фази Arrange, Act, Assert, описани по-горе.

### Sections за структуриране на тестове
Секциите позволяват тестване на различни аспекти на функционалност, споделяйки една и съща подготовка за теста.
```cpp
TEST_CASE("Testing Person related methods")
{
    Person p1 = createPerson(false, 15, "Fernando");
    Person p2 = createPerson(false, 22, "Ivan");
    Person p3 = createPerson(false, 22, "Maria");

    SECTION("Test isOlder when first person is older")
    {
        REQUIRE(isOlder(p2, p1));
        REQUIRE_FALSE(isOlder(p1, p2));
    }

    SECTION("Test isOlder when ages are equal")
    {
        REQUIRE_FALSE(isOlder(p2, p3));
        REQUIRE_FALSE(isOlder(p3, p2));
    }
}

```
#### Ползи от Sections
- Избягва повторението на предварителната настройка за тестовете
- Групира свързаните тестове
- Подобрява четимостта и поддържането (maintainability)

### Assertion Macros in Catch
В Catch2, assertion macros се използват за проверка на очакваното поведение в тестовите случаи. Тези макроси оценяват условията и съобщават за неуспех, ако очакванията не са изпълнени.

#### `REQUIRE` – Immediate Assertion Failure
- Ако условието се провали, тестът се **прекратява незабавно**.
- Използва се, когато неуспехът трябва да **прекъсне тестовия случай**.

```cpp
REQUIRE(2 + 2 == 4);  // Passes
REQUIRE(5 > 10);      // Fails and stops execution
```

#### `CHECK` – Continue on Failure
- Ако условието не се изпълни, тестът **продължава да се изпълнява**.
- Използва се, когато са необходими **множество assertions**, дори ако някои от тях се провалят.

```cpp
CHECK(2 + 2 == 4);  // Passes
CHECK(5 > 10);      // Fails but test continues
```

#### `REQUIRE_FALSE` / `CHECK_FALSE` – Expecting False
- Противоположно на `REQUIRE` и `CHECK`, като се очаква изразът да бъде **false**.

```cpp
REQUIRE_FALSE(5 > 10);  // Passes
CHECK_FALSE(2 + 2 == 5);  // Passes
```

## Потоци и Файлове. Текстови и бинарни файлове.

### Видове потоци:
- Потоци за вход (istream).
- Потоци за изход (ostream).

![Потоци](https://i.ibb.co/VDdDSnM/potoci.gif)

### Пример за работа с вход от конзолата - cin (обект от тип istream)

```c++
#include <iostream>

int main()
{
    int a, b;
    std::cin >> a >> b;
}
```

### Пример за работа с поток за изход - cout (обект от тип ostream)

```c++
#include <iostream>

int main()
{
    int a = 10;
    int b = 12;
    int c = a + b;

    std::cout << a << " + " << b << " = " << c << std::endl;
}
```

### Работа с поток за вход от файл (ifstream)

```c++
#include <iostream>
#include <fstream>

int main()
{
    std::ifstream file("myFile.txt"); // Трябва да съществува такъв файл!!!

    if (!file.is_open())
    {
        std::cout << "Error!" << std::endl;
        return -1;
    }
    int a, b;

    file >> a >> b;

    file.close();
}
```

### Работа с поток за изход към файл (ofstream)

```c++
#include <iostream>
#include <fstream>

int main()
{
    std::ofstream file("myFile.txt");

    if (!file.is_open())
    {
        std::cout << "Error!" << std::endl;
        return -1;
    }
    int a = 3;
    int b = 10;

    file << a << " " << b << " " << a + b << std::endl;

    file.close();
}
```

- **ifstream или istream** - `get` указател, който реферира елемента, който ще се прочете при следващата входна операция.
- **ofstream или ostream** - `put` указател, който реферира мястото, където ще се запише следващият елемент.

### Позициониране във файл

- `tellg()` - Връща позицията на текущия символ в **потока за четене**.
- `tellp()` - Връща позицията на текущия символ в **потока за писане**.
- `seekg(offset, direction)` - Премества `get`-указателят на **потока за четене** с `offset` символа в посоката, която е посочена.
- `seekg(streampos idx)` - Премества `get`-указателят на **потока за четене** на позиция `idx`.
- `seekp(offset, direction)` - Премества `put`-указателят на **потока за писане** с `offset` символа в посоката, която е посочена.
- `seekp(streampos idx)` - Премества `put`-указателят на **потока за писане** на позиция `idx`.

- **offset**: целочислена стойност. Отместването от `direction`.
- **direction**: Може да заема следните стойности:

  1. `ios::beg` - началото на файла.
  2. `ios::cur` - текущата позиция във файла.
  3. `ios::end` - края на файла.

### Режими на работа

```c++
ifstream str("file.txt", <режим на работа>);
```

Режимът на работа е цяло число.

| ios         | Ефект                                                                                                            |
|------------|----------------------------------------------------------------------------------------------------------------|
| ios::app   | Отваря за вмъкване без да изтрива съдържанието на файла. Вмъква се винаги в края на файла.                      |
| ios::ate   | Отваря за вмъкване и установява указателя `put` в края на файла. Позволява и вмъкване на произволни места.      |
| ios::binary| Превключва режима от текстов в двоичен.                                                                         |
| ios::in    | Отваря файл за извличане.                                                                                       |
| ios::out   | Отваря файл за вмъкване. Ако файлът съществува, съдържанието се изтрива.                                        |
| ios::trunc | Ако файлът съществува, съдържанието се изтрива.                                                                 |

```c++
ofstream file("file.txt", ios::out | ios::app);
```

### Флагове на състоянията на потока

| Флаг      | Значение                                                                         |
|-----------|---------------------------------------------------------------------------------|
| `bad()`   | Има загуба на информация. Някоя операция за четене и писане не е изпълнена.     |
| `fail()`  | Последната входно/изходна операция е невалидна.                                |
| `eof()`   | Достигнат е края на файла.                                                     |
| `good()`  | Всички операции са изпълнени успешно.                                          |
| `clear()` | Изчиства състоянието на потока (Вече `good()` ще върне истина).               |

## Примерни Задачи
**Задача 1**: Напишете програма, която при стартирането си получава аргументи и ги отпечатва на конзолата.

**Задача 2**: Напишете програма, която при стартирането си приема име на файл и отпечатва съдържанието му.

**Задача 3**: Да се напише функция, която намира големината на файл.