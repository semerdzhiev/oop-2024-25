### Ключови думи default, delete и explicit

#### default

Ключовата дума `default` служи за да подскажем на компилатора, че искаме да създаде конструктор или оператор със стандартно очаквана имплементация. Нека разгледаме следния пример:

```cpp
class T
{
public:
    T(const int x): x(x){}

private:
    int x;
};

int main()
{
    T el[10]; // Error!
    return 0;
}
```

Какво става, ако искаме да ползваме `default` конструктора на `T`? Ще ни даде грешка, както при декларирането на масив от този клас. Това е, защото когато дефинираме параметризиран конструктор в класа, компилаторът спира автоматично да генерира такъв по подразбиране. За целта можем да направим следното:

```cpp
class T
{
public:
    T() = default;
    T(const int x): x(x){}

private:
    int x;
};

int main()
{
    T el[10]; // OK!
    return 0;
}
```

Така сме показали на компилатора, че искаме да ни създаде такъв конструктор, без да има нужда да го разписваме.

#### delete

Ключовата дума `delete` служи за да подскажем на компилатора, че не искаме да създаде конструктор или оператор със стандартно очаквана имплементация. Нека разгледаме следния пример:

```cpp
class T
{
public:
    T(const char *str)
    {
        if(!str) return;
        this->str = new(std::nothrow) char[strlen(str)];
        if(this->str) strcpy(this->str, str);
    }
    ~T()
    {
        delete[] str;
    }

private:
    char *str = nullptr;
};

int main()
{
    T string("Hello");
    T temp(string);
    return 0;
}
```

Кодът ще се компилира, но ще използва стандартна имплементация на копиращия конструктор създадена от компилатора. Проблемът в случая е,

```cpp
class T
{
public:
    T(const char *str)
    {
        if(!str) return;
        this->str = new(std::nothrow) char[strlen(str)];
        if(this->str) strcpy(this->str, str);
    }
    T(const T&) = delete;
    ~T()
    {
        delete[] str;
    }

private:
    char *str = nullptr;
};

int main()
{
    T string("Hello");
    T temp(string); // Error!
    return 0;
}
```

Така сме оказали на компилатора да не създава копиращ конструктор и вече компилаторът ще ни се скара, че се опитваме да копираме нещо, което не може да се копира.

#### explicit

Ключовата дума explicit служи за да подскажем на компилатора, че искаме да конструкторът на някакъв клас трябва да бъде експлицитно извикан и не може да бъде извикан, чрез конверсия. Нека разгледаме следният пример:

```cpp
class A
{
public:
    A(int) { }      // converting constructor
    A(int, int) { } // converting constructor (C++11)
};

int main()
{
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    return 0;
}
```

Има ситуации, в които не е добра идея да викаме копие, на някакъв клас с число например. Затова можем да използваме ключовата дума explicit, която да забрани това поведение и то става по следният начин:

```c++
class A
{
public:
    explicit A(int) { }      // converting constructor
    explicit A(int, int) { } // converting constructor (C++11)
};

int main()
{
    A a1 = 1;      // Error: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // Error: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    return 0;
}
```

С помощта на тази ключова дума сме забранили тези не очевидни извиквания и странно поведение на нашият клас.

# Статични член-данни и член-функции

Когато се създава обект от даден клас, този обект разполага със **свое собствено копие** на член-данните. Когато обаче член-данните са декларирани като **статични (с ключовата дума static)**, те се **споделят от всички обекти на класа**.  

Характеристики на **статичните член-данни**:
1. Статичните член-данни се **декларират в класа**. Преди да бъдат използвани, те трябва да бъдат дефинирани и инициализирани. Освен в някои случаи, това се случва извън декларацията на класа.
2. Памет за статичните член-данни се заделя не върху стека, а в **областта за статични данни**.
3. **Памет за статичните член-данни се заделя еднократно**. Всички обекти от класа имат достъп до нея.
4. Статичните член-данни се създават, когато се стартира програмата и се унищожават, когато програмата приключи. Тъй като те съществуват преди изобщо да има създадени обекти от класа, **те се свързват със самия клас, а не с някой конкретен обект**. Най-добре е достъпът до тях да се осъществява през класа (с оператор за принадлежност :: ), а не през обект.  

Характеристики на **статичните член-функции**:
1. Тъй като статичните член-функции могат да бъдат извикани през самия клас, дори без да
съществуват обекти от този клас, то **в тях няма дефиниран указател this**.
2. След като не се изпълняват върху конкретен текущ обект, то в тях не могат да се използват
други член-данни на класа, които не са статични. **В статичните член-функции могат да се
използват само статични член-данни**.
3. Статичните член-функции **не могат да бъдат константни**. Причината отново е, че не се
изпълняват върху конкретен текущ обект.
4. Препоръчително е статичните член-функции (както и статичните член-данни) да бъдат
използвани **само с пълното име на класа, а не през обект**.

# Задача
Създайте клас Parking, който има определен капацитет от коли, които може да поеме (може да използвате класа Car от упражнение 03).
- В паркинга могат да се добавят и премахват коли.
- Поддържаме броя на колите, които са в паркинга

Модифицирайте класа за кола т.ч. всяка кола да има уникален идентификационен номер(цяло число), който й се задава вътрешно при създаването на колата.

- Покрийте класовете с тестове

