# Наследяване

  

Ако имаме клас, който споделя компоненти и/или поведение с вече съществуващ такъв,

то вместо да ги дефинираме наново, може да направим първия *наследник* на втория.

  

Наследникът съдържа всички член-данни и член-функции на родителския клас, които не са private.

  

Ако искаме дадени член-данни да се наследяват, но да няма външен достъп до тях,

можем да използваме модификатора за достъп *protected*.

  

Пример:

  

```c++

#include  <iostream>

  

class  Person {

char* name;

char[11] ucn;

protected:

size_t age;

public:

// getters / setters...

};

  

class  Student : public  Person {

  

protected:

char* fn;

public:

// getters / setters...

};

```

  

Тук Student няма да има директен достъп до name и ucn, но ще има до age.

  

## Видове наследяване

  

- private - всички член-данни стават private в наследения клас

- protected - всички член-данни стават protected в наследения клас

- public - всички член-данни запазват модификатора си за достъп

  

При класовете наследяването е private по подразбиране, а при структурите е public.

  

## Параметри на функции

  

```c++

class  Parent {

public:

int a = 0;

};

  

class  Child : public  Parent {

public:

int b = 0;

};

  

void  funcA(Parent&  p) {

p.a++;

};

void  funcB(Child&  c) {

c.b++;

};

  

int  main() {

Parent parent;

Child child;

funcA(parent); // a = 1

funcB(parent); // грешка!

funcA(child); // a = 1

funcB(child); // b = 1

}

```

  

## Конструктори, деструктори и оператори за присвояване

  

Във всеки конструктор на наследника трябва да се указва кой конструктор на базовия клас да се извика.

Ако не е указано, то ще се извика конструкторът по подразбиране на родителя.

  

В двата случая първо ще се извика този на базовия клас, а след това на наследника.

  

При деструкторите е обратното - при унищожаване на наследника първо се извиква неговият и след това на базовият.

  

```c++

class  Parent {

public:

Parent() {

std::cout << "Parent constructor" << std::endl;

}

~Parent() {

std::cout << "Parent destructor" << std::endl;

}

};

class  Child : public  Parent {

public:

Child() : Parent() {

std::cout << "Child constructor" << std::endl;

}

  

~Child() {

std::cout << "Child destructor" << std::endl;

}

};

  

int  main() {

Child child;

}

  

// Output:

// Parent constructor

// Child constructor

// Child destructor

// Parent destructor

```

  

При copy конструктора и оператора за присвояване на наследника викаме експлицитно съответните на родителския клас.

  

```c++

Child::Child(const Child& other) : Parent(other) {

// тук копираме само член-данните, които добавяме в наследника

}

  

Child&  Child::operator=(const  Child&  other) {

if (this != &other) {

Parent::operator=(other);

// обичайните за operator= неща, като трием и копираме само новите член-данни

}

return *this;

}

```

  
  

# Задача

# Меню :open_file_folder:

  

:fork_and_knife: \**На студентски стол*\* (преди нововъдението със стикерите...) - 2 порции от боба с наденица за тук и 2 порции от рулото "Стефани" за вкъщи, моля

  

:pen: \**По време на лекция по ДАА*\* - Внимамаш ли? Кажи ми, че не го слушаш... Колко време остава? Не мога повече, гладна съм... Писна ми... Какво ще ядем? Айде после до Шопската баница... Не, айде до Билата... И кафе трябва да си взема, умирам...

  

:lobster: \**В някой буржоазен ресторант*\* (доколкото един беден студент може да си позволи такъв, най-много Happy) - една малка лимонада с малини и едни Happy късчета (няма пари за суши :cry:)

  

:beers: \**На пейка-парти в Студентски парк*\* - Наздраве! (5-секундна наздравица от стъклени бирени бутилки)

  

:dancers: \**В Plazza\** - *Мария, Мария, с твоята магия...* Наздраве!!! *Имаме ли връзка с теб сега, или се разпадна внезапно тя...* Още един Jameson и една Finlandia, моля! *Не сме безгрешни, но сме истински...*

  

Гореизброените ситуации и още много такива описват ежедневната (ежечасната? ежеминутната? ежесекундната?) ни нужда от това редовно да се подкрепяме с вкусна храна и подходяща напитка. Разбира се, хубаво е изборът на храна и напитки винаги да е възможно най-лесен. Това би било възможно, ако всички опции са подредени и добре описани - точно като в едно добре направено меню в ресторант. В днешната задача ще направим именно това - ще създадем меню, в което можем да добавяме каквито си искаме храни и напитки.

  

### Menu Item :poultry_leg::cocktail:

  

Всеки един продукт в нашето меню ще има няколко задължителни атрибута - име, количество, кракто описание и цена. Реализирайте клас `MenuItem`, който да съдържа тази информация.

  

Нашето меню ще съдържа два основни вида продукти - храни и напитки:

  

### Food :hamburger:

  

Реализирайте клас `Food`, който освен атрибутите, специфични за всеки един продукт от менюто, пази информация и за това дали храната е голяма, или малка, и също така дали е подходяща за вегани, или не.

  

### Drink :cup_with_straw:

  

Освен атрибутите на всеки един продукт от менюто, обектите от тип `Drink` трябва да съдържат информация дали напитката се сервира в чаша, в кана или в бутилка.

  

### Alcohol :tumbler_glass:

  

Някои от напитките в нашето меню са по-специфични - не са подходящи за малки деца и определено не влияят по най-добрия начин на някои студенти. Това са алкохолните напитки. Реализирайте клас `Alcohol`, който освен специфичните за напитките атрибути, съдържа информация и за това колко процента алкохол се съдържат в напитката.

  

За всеки един от горепосочените класове:

- Следвайте Rule of 0/3!

- Не реализайте конструктори по подразбиране. Вместо това, създайте конструктори с параметри, приемащи всички член-данни за съответния клас.

- Да се имплементира метод `getInfo`, който дава информация във формат по ваш избор за съответния продукт от менюто

  

>  **Забележка:** Ако за проектите вече сте си реализирали сами клас `string` и/или вече се чувствате достатъчно сигурни в знанията си, свързани с работата с динамична памет, то използвайте наготово класа `std::string` за работа с низове. В противен случай, продължавайте да се упражнявате и използвайте динамично заделени масиви от тип `char*`

  

### Menu :memo:

  

Дойде времето да създадем и нашето меню. Ще направим това, като реализираме клас `Menu`, представляващ саморазширяващ се масив, съдържащ обекти от тип `MenuItem`, `Food`, `Drink` и `Alcohol`.

  

Нашето меню ще е едно-единствено, не искаме да позволяваме да се създават много инстанции от него, нито искаме да се създават негови копия. Реализирайте design pattern-a `Singleton` за класа `Menu`, за да постигнете това.

  

Да се реализира:

- различни методи за добавяне на всеки един от видовете продукти (включително и от `MenuItem` - може в менюто да има нещо, което не е нито храна, нито напитка, кой знае...)

- метод за принтиране на менюто

- метод, връщащ най-евтиния продукт в менюто

- БОНУС:

- метод, даващ информация колко безалкохолни напитки има в менюто

- метод, връщаш напитката с най-висок процент алкохол

  

### :warning: Забележки

  

- Погрижете се за правилното използване на динамична памет и не допускайте memory leaks

- Целете се към максимално спазване на чист код