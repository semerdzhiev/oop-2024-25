<h1>Unit testing</h1>

<h3>Дефиниция</h3>

Тестването на индивидуални софтуерни компоненти (units).

<h3>Какво представлява unit?</h3>

Unit е най-малката частица код, която може да се test-ва (или си заслужава да се тества).
Обикновено това може да е цял модул, но в повечето случаи е функция или метод.
Има 1 или няколко входа и **един** изход.

*Някои от по-известните framework-ове.*

|Language  |Test framework  |
|----------|----------------|
|C++       |Catch2, doctest|
|C#        |NUnit, csUnit   |
|Java      |JUnit, Jtest    |
|JavaScript|JSUnit, QUnit   |

<h3>Какъв подход се използва за писане на unit тестове?</h3>

- най-използвания подход е test \- function \- expected value
- идеята е, че тестваме точно определена функционалност
- В помощ на unit test-овете влизат method stubs, mock objects, fakes и test harnesses, 
като идеята е, че те ни позволяват да се фокусираме над това, което тестваме
- Целта на unit test-овете е да изолират всяка една част на програмата и да покажат, че е коректна.
- Unit test-овете намират проблеми от рано в development процесът

<h3>Code coverage</h3>

Code coverage е измеримост на това, колко линии/блокове от нашия код са изпълнени, докато автоматизираните тестове текат.

<h3>White vs Black box testing</h3>

- Black Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок не са известни на този, който ги тества.
- White Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок са известни на този, който ги тества.

<h3>Кой пише unit тестове?</h3>

- Обикновенно самите софтуерни разработчици пишат тестовете си.

<h3>Ползи от unit тестове</h3>

- Unit тестовете осигурява сигурност при промяна/поддръжка на кода ни.
- Кодът става преизползваем, защото кодът става на модули, които могат да бъдат тествани отделно.
- Усилията, които ще ни коства да оправим дефект, засечен по време на тестване, са по-малко отколкото да оправим дефект, засечен на по-високо ниво.
- Debug-ването е по-лесно.

<h3>Примери от живота</h3>

Нека приемем, че имаме програма, която се състои от два unit-а и единственият тест, който правим е системен тест. (Пропускаме unit и integration тестовете.)
По време на тестване намираме bug в програмата. Сега, как ще определим от къде идва той?

Имаме следните варианти:

- В unit 1 ли е проблемът?
- В unit 2 ли е проблемът?
- И в двата unit-а ли има проблеми?
- Проблемът в интерфейса между двата unit-а ли е?
- Проблемът в тестът или в тест case-ът е?

<h3>Catch2</h3>

- **[Тук](https://github.com/catchorg/Catch2)** можете да намерите catch2 framework-а.

<h3>Test Driven Development (TDD)</h3>

**Test-driven development (TDD)** е процес за софтуерна разработка, който разчита на повторението на един много кратък цикъл на разработка:

- Първо програмистът пише тест, който не минава, обаче дефинира желано подобрение или нова функционалност.
- След това пише код, който да минава тестът.
- И накрая рефакторира новият код, за да е по-четим.

TDD методът за работа може да се опише, като повторение на следните стъпки (показани на снимката):

- Избираме, коя функционалност трябва да се имплементира.
- Добавяме тест(ове) за избраната функционалност.
- Компилираме, тестваме и гледаме дали има някакви грешки.
- Пишем код, който да работи.
- Рефакторираме написаният код.
- Повтаряме тестовете, оправяме кода ако има грешни тестове.
- Commit-ваме промените.
- Отиваме на следващата функционалност и повтаряме стъпките.

![](https://i.ibb.co/61tp58D/TDD.png)

<h3>Как да организираме тестовете си</h3>

Тестовите случаи често се комбинират в тестови пакети според някакъв критерии - подобна функционалналност, различни употреби за една и съща функция, общи приспособления и т.н.

Добър начин по който да ги организираме:

- Тестовият случай трябва да тестваме само едно нещо;
- Тестовият случай трябва да е кратък;
- Тестът трябва да работи бързо, за да може да се прави често;
- Всеки тест трябва да работи независимо о<h1>Unit testing</h1>

<h3>Дефиниция</h3>

Тестването на индивидуални софтуерни компоненти (units).

<h3>Какво представлява unit?</h3>

Unit е най-малката частица код, която може да се test-ва (или си заслужава да се тества).
Обикновено това може да е цял модул, но в повечето случаи е функция или метод.
Има 1 или няколко входа и **един** изход.

*Някои от по-известните framework-ове.*

|Language  |Test framework  |
|----------|----------------|
|C++       |Catch2, doctest|
|C#        |NUnit, csUnit   |
|Java      |JUnit, Jtest    |
|JavaScript|JSUnit, QUnit   |

<h3>Какъв подход се използва за писане на unit тестове?</h3>

- най-използвания подход е test \- function \- expected value
- идеята е, че тестваме точно определена функционалност
- В помощ на unit test-овете влизат method stubs, mock objects, fakes и test harnesses, 
като идеята е, че те ни позволяват да се фокусираме над това, което тестваме
- Целта на unit test-овете е да изолират всяка една част на програмата и да покажат, че е коректна.
- Unit test-овете намират проблеми от рано в development процесът

<h3>Code coverage</h3>

Code coverage е измеримост на това, колко линии/блокове от нашия код са изпълнени, докато автоматизираните тестове текат.

<h3>White vs Black box testing</h3>

- Black Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок не са известни на този, който ги тества.
- White Box Testing е метод на тестване, при който вътрешната структура/дизайн/имплементация на тестваният блок са известни на този, който ги тества.

<h3>Кой пише unit тестове?</h3>

- Обикновенно самите софтуерни разработчици пишат тестовете си.

<h3>Ползи от unit тестове</h3>

- Unit тестовете осигурява сигурност при промяна/поддръжка на кода ни.
- Кодът става преизползваем, защото кодът става на модули, които могат да бъдат тествани отделно.
- Усилията, които ще ни коства да оправим дефект, засечен по време на тестване, са по-малко отколкото да оправим дефект, засечен на по-високо ниво.
- Debug-ването е по-лесно.

![](https://www.twilio.com/content/dam/twilio-com/global/en/blog/legacy/2022/unit-integration-end-to-end-testing-difference/MyR86UeunZJcErQJmlEoEwWpAt56uIH2k2mHFqfsA95S2Rh9JsLmp0J6spDvo2XgdulDZ3oh0pIA_c6npsI7.png)

<h3>Примери от живота</h3>

Нека приемем, че имаме програма, която се състои от два unit-а и единственият тест, който правим е системен тест. (Пропускаме unit и integration тестовете.)
По време на тестване намираме bug в програмата. Сега, как ще определим от къде идва той?

Имаме следните варианти:

- В unit 1 ли е проблемът?
- В unit 2 ли е проблемът?
- И в двата unit-а ли има проблеми?
- Проблемът в интерфейса между двата unit-а ли е?
- Проблемът в тестът или в тест case-ът е?

<h3>Catch2</h3>

- **[Тук](https://github.com/catchorg/Catch2)** можете да намерите catch2 framework-а.

<h3>Test Driven Development (TDD)</h3>

**Test-driven development (TDD)** е процес за софтуерна разработка, който разчита на повторението на един много кратък цикъл на разработка:

- Първо програмистът пише тест, който не минава, обаче дефинира желано подобрение или нова функционалност.
- След това пише код, който да минава тестът.
- И накрая рефакторира новият код, за да е по-четим.

TDD методът за работа може да се опише, като повторение на следните стъпки (показани на снимката):

- Избираме, коя функционалност трябва да се имплементира.
- Добавяме тест(ове) за избраната функционалност.
- Компилираме, тестваме и гледаме дали има някакви грешки.
- Пишем код, който да работи.
- Рефакторираме написаният код.
- Повтаряме тестовете, оправяме кода ако има грешни тестове.
- Commit-ваме промените.
- Отиваме на следващата функционалност и повтаряме стъпките.

![](https://i.ibb.co/61tp58D/TDD.png)

<h3>Как да организираме тестовете си</h3>

Тестовите случаи често се комбинират в тестови пакети според някакъв критерии - подобна функционалналност, различни употреби за една и съща функция, общи приспособления и т.н.

Добър начин по който да ги организираме:

- Тестовият случай трябва да тестваме само едно нещо;
- Тестовият случай трябва да е кратък;
- Тестът трябва да работи бързо, за да може да се прави често;
- Всеки тест трябва да работи независимо от другите тестове. Грешен или неправилно направен тестови случай не трябва да пречи на другите тестове;
- Тестовете не трябва да разчитат на поредността, в която са пуснати;

- Ако се хвърли някаква грешка от някой от тестовете, програмата ще приключи и няма как да го спрем;
- Няма как да направим тест, който проверява конкретна подсистема на тестваният unit;

<h3>Mocking</h3>

В unit testing-а, mock objects могат да симулират поведението на комплекси обекти, които бихме използвали в реална ситуация. Ако имаме някое от следните характеристики за нашите обекти, mock обект би бил подходящ:

- Връща недетерминистични резултати (времето сега, температурата навън);
- Има ситации, които са трудни за пресъздаване (network error);
- Бавна инициализация (цяла база данни);
- Още не съществува или може да промени поведението си;
- Трябва да добави информация и методи, само заради тестоването (а не за своята задача);

<h3>Работа в практикум / Домашно</h3>

**Задача 1**

Реализирайте клас Drone със следните полета:
- идентификационен номер - низ с произволна (!) дължина
- път - масив с максимална дължина 32, съставен от позициите, на които трябва да отиде дронът. Пътят може да е тривиален (само началната позиция)
- текуща позиция - реални координати в равнината. Началната позиция е първата такава от пътя. Ще считаме, че всички съществени дронове са на позиция, различна от (0, 0)
- дължина на път - броят на позициите в оставащия път

Класът трябва да съдържа следните функции:
- конструктори и operator=
- void printCurrentPos(), която извежда текущата позиция на дрона на стандартния изход
- void printRemainingPath(), която извежда оставащия път (без текущата позиция) на дрона на стандартния изход
- bool moveWithOneStep(), която премества дронът на следващата позиция от пътя. Ако такава няма, функцията да връща false

Създайте клас DroneShow, който има следните полета:
- име - низ с максимална дължина 127 (колко голям трябва да е масивът?)
- дронове - масив с максимална дължина 64.

Класът трябва да реализира следните функционалности:
- конструктор, които инициализира полетата на класа
- void play() - извежда всички позиции на дроновете в реда им в масива и ги премества на следващата позиция от пътя, като това продължава докато за всички дронове остават валидни позиции. Приемете, че всички дронове имат еднакъв брой позиции в пътищата им.

Напишете подходящи тестове за всеки от двата класа.


### Допълнителни задачи:

Имплементирайте класовете `Vector` и `String` и ги покриите с подходящи тестове.