# Статични компоненти на класове. Move семантики

## Статични член-данни и член-функции

Ако декларираме член-данни като статични, то те се споделят от всички обекти на класа. Това се прави с ключовата дума ```static```.

Относно статичните член-данни:
- Те се декларират в класа, като трябва да бъдат дефинирани и инициализирани преди да се използват. Това обикновено се прави извън декларацията на класа.
- Паметта за тях се заделя еднократно в областта за статични данни при стартиране на програмата, като всички обекти на класа имат достъп до нея. Тя се освобождава чак при приключване на програмата.
- Свързват се със самия клас, а не с обект.
- Най-често ще ги достъпваме с оператора за принадлежност ::, а не през някой конкретен обект.

Относно статичните член-функции:
- В тях не можем да използваме указателя this и член-данни, които не са статични.
- Те не могат да бъдат константни.
- Най-често ще ги достъпваме с оператора за принадлежност ::, а не през някой конкретен обект. 

## Move семантики

### lvalue и rvalue

Всеки израз в C++ е или lvalue, или rvalue. lvalue наричаме данни, които са именовани и/или имат адрес в паметта, а rvalue - които не са lvalue.

Примери:

```c++
// Тук a е lvalue и можем да я модифицираме
int a;
a = 4;

// Това също е валидно!
int x;

int& getX() {
    return x;
}

getX() = 10; // тук getX() е lvalue стойност
```

```c++
// Това не е валидно!
4 = var; // Тук 4 е rvalue
(var + 1) = 4; // Тук var + 1 е rvalue

// Тук вече се връща копие, а не референция към обекта
int x;

int getX() {
    return x;
}

getX() = 5; // грешка! getX() е rvalue стойност
```

Можем да забележим, че rvalue стойностите се отнасят главно към обекти, които са временни и/или пред изтриване.

За да ги разпознаваме, ще използваме rvalue референции. Досега сме разглеждали lvalue референции, като тези се пишат с &&: 

```c++
int i = 42;
int& ref1 = i; // ок
int&& ref2 = i; // не е ок

int& ref3 = i * 2; // не е ок
int&& ref4 = i * 2; // ок

int x = 2;
int&& xRef1 = x; // не е ок
int&& xRef2 = std::move(x); // ок
```

### Move конструктор и Move оператор за присвояване

За разлика от нормалния copy конструктор и operator=, които копират данните на подадения обект, move конструкторът и move оператора за присвояване ги 'крадат' и ги променят така, че да станат независими от rvalue стойността.

```c++

class Student() {
    char* name;
    size_t age;
    Student();
    ~Student();
    Student(const Student& other);
    Student& operator=(const Student& other);

    // Move семантики
    Student(Student&& other);
    Student& operator=(Student&& other);
};

// Move конструктор
Student::Student(Student&& other) {
    this->name = other.name;
    other.name = nullptr;

    this->age = other.age;
}

// Move оператор за присвояване
Student& Student::operator=(Student&& other) {
    if(this != &other) {
        delete[] name;

        name = other.name;
        age = other.age;

        other.age = nullptr;
    }
    return *this;
}
```

## Задачи

### Задача 1

Създайте клас Counter, който представлява брояч със следния интерфейс:
- inc(unsigned n) - увеличава брояча с n
- dec(unsigned n) - намаля брояча с n
- inc() - увеличава брояча с единица
- dec() - намаля брояча с единица
- value() - връща текущата стойност на брояча

Класът трябва да бъде реализиран чрез статични член-данни и член-функции.

### Задача 2

Създайте клас VendingMachine, който представлява система за управление на автомат за напитки. Всяка напитка съдържа име, количество и цена.

Той трябва да съдържа следния интерфейс:
- void addDrink(const Drink& drink) - добавя напитката в системата. Ако вече съществува напитка с такова име, да се хвърли грешка.
- void removeDrink(const char* name) - премахва напитката с подаденото име от системата. Ако такава не съществува, да се изведе грешка.
- void fillDrink(const char* name, size_t quantity) - допълва напитката с подаденото име с подаденото количество.
- double buyDrink(const char* name, const unsigned quantity, const double payment) - купува напитката с подаденото име (ако съществува) и с подаденото количество. Функцията да връща рестото, ако има такова. Да се изведе грешка, ако платената сума не е достатъчна.
- double income() - връща дохода, който е в системата в момента
- double withdraw() - извлича и занулява доходите в системата

Имплементирайте необходимите конструктори, както и move семантики.