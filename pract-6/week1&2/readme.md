
# Член-функции. Жизнен цикъл на обект. Конструктори и деструктор. Капсулация. Модификатори за достъп. Член-функции *get* и *set*.

## Член-функции.
Функции, които работят с член-данните на обекта от дадена структура.
 ```c++
struct Rectangle
{
    int width;
    int height;
};

int GetArea(const Rectangle& r)
{
    return r.width * r.height;
}

int main()
{
    Rectangle r1 = {5, 6};
    Rectangle r2 = {3, 4};

    std::cout << GetArea(r1) << std::endl;
    std::cout << GetArea(r2) << std::endl;
}
 ```
 
Може функцията да бъде член-функция:
 ```c++
struct Rectangle
{
    int width;
    int height;

    int GetArea() const
    {
        return width * height;
    }
};

int main()
{
    Rectangle r1 = {5, 6};
    Rectangle r2 = {3, 4};

    std::cout << "Area of r1: " << r1.GetArea() << std::endl;
    std::cout << "Area of r2: " << r2.GetArea() << std::endl;
}
 ```
#  
**Основни неща за член-функциите**:
 - Работят с член-данните на класа.
 -  Извикват се с обект на класа
 - Компилаторът преобразува всяка **член-функция** на дадена структура в обикновена функция с уникално име и един допълнителен параметър – **константен указател към обекта**.

```c++
bool Rectangle::getArea()
{
	return width * height;
}
```

се превежда в:

```c++
bool Rectangle::getArea(Rectangle* const this)
{
	return this->width * this->height;
}
```

Забележете, че this е const указател към Point, т.е. не можем да меним this, но можем да променяме сочения от него обект.
Съответно:

```c++
rect.getArea();
```

се превежда в:

```c++
Rectangle::getArea(&rect);
```

**Основни неща за константни член-функции**:

 -  Не променят член-данните на структурата
 -  Оказва се чрез записването на ключовата  дума **const** в края
 -  Могат да се извикват от константни обекти.

## Конструктори и деструктор.

**Жизнен цикъл на обект**:
 - Създаване на обект в даден scope – заделя се памет и член-данните се инициализират.
 - Достига се до края на областта (scope-a).
 - Обектът и паметта, която е асоциирана с него, се разрушава.

**Конструктор**:
 - Извиква се веднъж - при създаването на обекта.
 - Не се оказва експлицитно тип на връщане (връща констатна референция).
 - Има същото име като класа.
 - Задава стойности на член-данните на class-a (в тялото си или чрез **member initializer list**) 
 
**Деструктор**:
 - Извиква се веднъж - при изтриването на обекта.
 - Не се оказва експлицитно тип на връщане.
 - Има същото име като класа със символа '~' в началото.

 **При липсата на дефинирани конструктори или деструктори, компилаторът автоматично създава такива по подразбиране.**
 ```c++
#include <iostream>

struct Test 
{
  Test()
  {
  	std::cout << "Object is created" << std::endl;
  }
  
 ~Test()
  {
  	std::cout << "Object is destroyed" << std::endl;
  }

  int a, b;
};

int main()
{
	{
		Test t; // Object is created 
			{
				Test t2; // Object is created 
			} // Object is destroyed (t2)

	} //Object is destroyed (t)
}
 ```
 
  ## Конструктори и деструктор при влагане на обекти.
 
  ```c++
#include <iostream>
#include <iomanip>

using namespace std;

struct A
{
	A()
	{
		std::cout << "Constructor(default) of A" << std::endl;
	}

	~A()
	{
		std::cout << "Destructor of A" << std::endl;
	}
};

struct B
{
	B()
	{
		std::cout << "Constructor(default) of B" << std::endl;
	}

	~B()
	{
		std::cout << "Destructor of B" << std::endl;
	}
};

struct C
{
	C()
	{
		std::cout << "Constructor(default) of C" << std::endl;
	}

	~C()
	{
		std::cout << "Destructor of C" << std::endl;
	}
};

struct X
{
	A first;
	B second;
	C objectsArray[3];

	X()
	{ //calls Constructor(default) of A, Constructor(default) of B, Constructor(default) of C" (x3)
		std::cout << "Constructor of X" << std::endl;
	}
	~X()
	{
		std::cout << "Destructor of X" << std::endl;
	} //calls Destructor of C" (x3) , Destructor of B, Destructor of A

};

int main()
{
	X  obj; //Constructor of X
} // Destructor of X
 ```
 
 ## Капсулация (encapsulation).
 **Капсулацията** (известно още като "скриване на информация") е един от основните принципи в ООП. Тя налага разбиването на един клас на интерфейс и имплементация. Интерфейсът включва набор от операции, които потребителят може да използва, без да има нужда да се притеснява как е реализирана тяхната вътрешна логика.
Има случаи, в които искаме да **ограничим достъпа до всички данни и методи на даден клас**. Това е необходимо, защото промяна в тях може да доведе до неочаквано поведение на програмата. Принципът на капсулация ни дава възможност да **контролираме кои методи и свойства ще бъдат достъпни** за потребителите на класа ни.

**Модификатор за достъп**:
 
| Модификатор за достъп: | Достъп:                         |
|------------------------|---------------------------------|
| private                | В текущия клас.                 |
| protected              | В текущия клас и *наследниците му. |
| public                 | За всеки                        |

 ## Селектори и мутатори
Това са публични член-функции, които се използват за достъпване (get) и промяна (set) на член-данни, които са декларирани в private/protected секция на един клас.

**Пример за get-ъри и set-ъри**
```c++
#include <iostream>

struct Student
{
private:
	int grade = 2;
	int age = 0;
public:
	Student(int grade, int age) {
		setGrade(grade);
		setAge(age);
	}

	int getGrade() const
	{
		return grade;
	}

	int getAge() const
	{
		return age;
	}

	void setGrade(int grade)
	{
		if (grade < 2 || grade > 6) {
			std::cout << "Invalid value for grade!" << std::endl;
			return;
		}

		this->grade = grade;
	}

	void setAge(int age)
	{
		if (age < 0) {
			std::cout << "Invalid value for age!" << std::endl;
			return;
		}

		this->age = age;
	}
};
```
**Забележка! При създаване на обект трябва да подсигурите, че той е във валидно състояние. Оставянето му във невалидно такова е сериозна грешка!**

### Mutable (пример)
Спецификатора mutable е приложен само в С++. Той позволява на член на обект да предефинира константността. Така mutable член на const обект не е const и може да бъде изменян.
 ```c++
struct Test
{
private:
	mutable int n = 0;
public:
	void f() const
	{
		n++;
	}

};

int main()
{
	const Test t;

	t.f();
}
```

## Задачи

**Задача 1:**
Реализирайте клас/структура интервал, който представлява интервал  [a,b]  (задължително а <= b) от реалната права. Нашият интервал ще бъде дискретен - началото и краят му ще бъдат цели числа и ще разглеждаме само точки, които са цели числа. Релизирайте следният интерфейс:

 - Подразбиращ се конструктор, който създава интервала **[0,0]**.
 - Конструктор, който приема двата параметъра. Ако a<=b, то създава интервала **[a,b]**. В противен случай, създава **[0,0]**.
 - Член-функция, която връща **дължината на интервала**.
 - Член-функция, която приема число и проверява **дали е част от интервала**.
 - Член-функция, която връща **броя на простите числа** в интервала.
 - Член-функция, която връща **броя на числата в интервала**, които са палиндорми.
 - Член-функция, която връща **броя на числата, които нямат повтарящи цифри**.
 - Член-функция, която връща дали началото и края на интервала са **степени на 2-ката**. ([2,16] - истина) 
 - Член-функция, която приема интервал и връща **сечението на текущия интервал с подадения**.  (Сечението на [1, 5]  [3, 7]  e [3, 5]).
 - Член-функция, която приема интервал и връща дали подадения (като параметър) интервал е **подинтервал на текущия**(обектът, от който се извиква функцията).

  **Пример за работа с класа:**
 ```c++

int main()
{
     Interval t1(3,10); // [3, 10]
     Interval t2(4,14); // [4, 14]
     Interval t3; // [0, 0]

     Interval result = t1.intersect(t2); // [4, 10]
     
     t2.isSuperInterval(result); //true
     
     result.calcPrimeNumbersInTheInterval() // 2 (only 5 and 7)
}
 ```

**Задача 2:**

Реализирайте клас **Time**, който ще се използва за работа с часове (13:05:45).
Вашият клас трябва да има следния интерфейс:

 - Подразбиращ се контруктор, който създава часа на **00:00:00**.
 - Конструктор, който приема три параметъра - **час, минути и секунди**.
 - Член-функция, която връща оставащото време до **полунощ**.
 - Член-функция, която увеличава часа с 1 секунда.
 - Член-функция, която връща дали е **време за вечеря**. В рамките на задачата време за вечеря е между **20:30** и **22:00**.
 - Член-функция, която връща дали е **време за парти**. В рамките на задачата време за парти е между **23:00** и **06:00**.
  - Член-функция, която приема друг обект от тип **Time** и връща обект от тип **Time**, което е разликата между двете времена. 
  - Член-функция, която която приема друг обект от тип **Time**  и сравнява двата обекта (по-къснен/по-ранен)
  - Член-функция за принтиране на часа.

Да се направи масив от 10 времена и да се сортира стабилно с някоя от изучаваните сортировки.

##*Присъстват материали, взаимствани от github хранилището на Ангел Димитриев*